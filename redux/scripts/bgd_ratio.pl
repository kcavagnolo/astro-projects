#! /usr/bin/perl -w
#
# NAME:
#     bgd_ratio.pl
#
# PURPOSE:
#     This script calculates the 9-12 keV count rate on the off-axis
#     chip of an observation and the corresponding deep bgd chip. The
#     ratio of these count rates is then output to a file and will be
#     used later to normalize background spectra to account for
#     variation of the hard particle background as a function of
#     location in the sky and time.
#
# EXPLANATION:
#     This script assumes the following directory structure:
#     $loc/$obsid/$rootdir
#
#     $loc is specified as the last column of the input file
#     $obsid is specified as the second column of the input file
#     $rootdir is specified in the 'options' section of this script
#
#     Example:
#     For $loc /mnt/DROBO and $obsid 2211 and $rootdir reprocessed,
#     this script will look in /mnt/DROBO/2211/reprocessed for all the
#     files needed to complete the data reduction
#
#     ** New files will be placed in the directory defined by the
#     variable $rootdir **
#
# CALLING SEQUENCE:
#     unix%> perl bgd_ratio.pl <reference list>
#
# FILES ASSUMED TO EXIST:
#     a) Events file for off-axis target field
#     b) Events file for corresponding off-axis deep bgd field
#     NB: Both of these files are generated by reprocess.pl, or can be
#     forced into existence using force_bgd.pl
#
# INPUTS:
#     <reference list> -- File containing information about each cluster
#
#     Example:
#     #Name                      ObsID      X      Y   Rmax  MinCts        z   Nh20     Tx     Fe   Lbol  Chip    E_obs  Diff   Robs   Location
#     1E0657_56                   3184   3776   4026    590    5000   0.2960   6.53  11.64   0.23  46.20    i3   1.5432     y    200   /mnt/DROBO
#
# KEY OUTPUTS:
#     A logfile containing important numbers, this file is specified
#     with the $logfile variable below
#
#######################
#######################
##    Set Options    ##
#######################
#######################

$restore  = "no";                    # restore background exposure time to it's original value, OGEXP
$uselocal = "no";                    # should we use a local bgd region?
$lregext  = "ignore";                # name of local bgd region
$logfile  = "all_bgd_9-12.dat";      # Name of the file to be written by script
$emin     = 9500;                    # minimum energy, in eV, to use for bgd count rate
$emax     = 12000;                   # maximum energy, in eV, to use for bgd count rate
$rootdir  = "reprocessed/";          # name of directory storing evt files
$verb     = 1;                       # verbosity

#######################
#######################

# some checks
use Cwd;
use FindBin qw($Bin);
die "## ERROR: ciao is not loaded\n" unless ($ENV{'ASCDS_BIN'});
die "## Wrong number of command line arguments\n" if (@ARGV != 1);

# define the quiescent bgd rate for each period in the 0.3-10.0 keV
# band. these are no longer correct, but... whatever
%qrate = ("As2"=>"0.1", "As3"=>"0.2",
	  "Bi0"=>"0.3947", "Bi1"=>"0.4005", "Bi2"=>"0.3959", "Bi3"=>"0.4328",
	  "Bs1"=>"2.2413", "Bs2"=>"0.4327", "Bs3"=>"1.4400", "Bs4"=>"0.4424",
	  "Ci0"=>"0.3415", "Ci1"=>"0.3497", "Ci2"=>"0.3434", "Ci3"=>"0.3519",
	  "Cs1"=>"1.9704", "Cs2"=>"0.3889", "Cs3"=>"1.2747", "Cs4"=>"0.3857",
	  "Di0"=>"0.3873", "Di1"=>"0.3995", "Di2"=>"0.3938", "Di3"=>"0.4045",
	  "Ds1"=>"2.1466", "Ds2"=>"0.3978", "Ds3"=>"1.3177", "Ds4"=>"0.4044",
	  "Dvfi0"=>"0.2674", "Dvfi1"=>"0.2743", "Dvfi2"=>"0.2700", "Dvfi3"=>"0.2772",
	  "Dvfs1"=>"1.8111", "Dvfs2"=>"0.2768", "Dvfs3"=>"1.0772", "Dvfs4"=>"0.2675");

# read in the reference file
%refdata  = get_data($ARGV[0]);

# open file to contain results
open(FITFILE,">>$Bin/${logfile}");
print_info();
close FITFILE;

# open err log
open(ERR,">>err_bgd_ratio.log");

# go through each cluster and extract events, images
foreach $key (sort keys %refdata) {

    # split up the data line
    @data = split(/\s+/,$refdata{$key});

    # get obsid
    $name    = $data[0];
    $obsid   = $data[1];
    $id      = $data[11];
    $raw_id  = $id;
    $id      = "i0123" if ($id =~ /^i/);
    $addex   = "no";
    $datadir = $data[15];
    print "## Starting ${obsid}\n";

    # define the ccd to use and file names
    chdir("$datadir/$obsid/$rootdir/");
    $evtfile  = "${obsid}_exclude.fits";
    $dbgdfile = "${obsid}_bgevt.fits";
    $bpix     = "${obsid}_bpix.fits";

    # decide which files to use
    if ($uselocal eq "yes") {
	$bgfile = "${obsid}_bgevt.fits";
	$region = "${obsid}_${lregext}.reg";
	$bgccd = $raw_id;
    } elsif ($emin <= 9000) {
	$bgfile = "${obsid}_addex_bgd.fits";
	$evtfile = "${obsid}_addex_src.fits";
	$bgccd = "na";
	$addex = "yes";
    } else {
	if ($id =~ /^i/) {
	    $bgccd = "6";
	    $bgfile = "${obsid}_s2_bgevt.fits";
	} else {
	    $bgccd = "2";
	    $bgfile = "${obsid}_i2_bgevt.fits";
	}
	
	# change the name if an alternate chip was used
	unless (-e $bgfile) {
	    if ($id =~ /^i/) {
		$bgccd = "7";
		$bgfile = "${obsid}_s3_bgevt.fits";
	    } elsif ($id =~ /^s/) {
		$bgccd = "3";
		$bgfile = "${obsid}_i3_bgevt.fits";
	    } else {
		print "## ERROR: You've given me a bad chip_id... sinner >:)\n";
	    }
	}
    }

    # set badpix file
    system(`punlearn ardlib.par; punlearn acis_set_ardlib`);
    system(`acis_set_ardlib $bpix verb=0`);

    # make sure we have bgd files to work with
    unless (-e $bgfile) {
	print "## No $bgfile file for $obsid ($name)\n";
	print ERR "${obsid}: No $bgfile file\n";
	$obsrate = 0;
	$deeprate = 1;
	$qbgd = 1;
	bgd_ratio($obsrate,$deeprate,$qbgd);
	chdir($Bin);
	next;
    }

    # check for altered files
    $ogbexp = `dmkeypar $dbgdfile OGEXP; pget dmkeypar exist`;
    chomp($ogbexp);
    if ($ogbexp eq "yes") {
        print "## STATUS: Bgd file was previously altered, reverting...\n";
        $ogbexp = `dmkeypar $dbgdfile OGEXP; pget dmkeypar value`;
	chomp($ogbexp);
	$ogbexp = sprintf("%f",$ogbexp);
	@keys = qw(EXPOSURE ONTIME LIVETIME);
	@files = ($dbgdfile, $bgfile);
	foreach $file (@files) {
	    $command = "dmhedit $file filelist=none operation=del key=OGEXP";
	    system($command);
	    foreach $timekey (@keys) {
		$command = "dmhedit $file filelist=none operation=add key=$timekey value=$ogbexp datatype=float";
		system($command);
	    }
	}
    }
    next if ($restore eq "yes");

    # make sure we have events files to work with
    unless (-e $evtfile) {
	print "## ERROR: No $evtfile file for $obsid ($name)\n";
	print ERR "${name} ${obsid} No $evtfile file\n";
	$obsrate = 0;
	$deeprate = 1;
	$qbgd = 1;
	bgd_ratio($obsrate,$deeprate,$qbgd);
	chdir($Bin);
	next;
    }

    # set quiescent bgd rate
    $qbgd = set_qbgd($evtfile);
    $qbgd = -1.0 if ($qbgd eq "");

    # extract spectrum for obs background and deep background
    $obsrate  = extract_obsbgd($evtfile);
    $deeprate = extract_deepbgd($bgfile);

    # compute and write ratio of obs bgd to quiescent bgd to output file
    $bgdratio = bgd_ratio($obsrate,$deeprate,$qbgd);

    # adjust deep bgd FITS file
    adj_deep($dbgdfile,$bgfile,$bgdratio);

    # clean-up
    unlink("deepcts.log");
    unlink("obscts.log");

    # change back to original directory
    chdir("$Bin");
    print "## Finished ${obsid}\n";

}
print "## Finished bgd ratio ",scalar(localtime),"\n";
close ERR;
exit 0;

#######################
#######################
#### Sub routines #####
#######################
#######################

sub get_data {

    my($infile) = @_;
    my(@data,$name,%info);
    open(INFILE,$infile) || die "## ERROR: Cannot open $infile\n";
    while (<INFILE>) {
	chomp;
	next if (/^\#/); # skip comment lines
	next if (/^$/);  # skip blank lines
	s/^\s+//;        # trim leading whitespace
	s/\s+$//;        # trim trailing whitespace
	@data = split;
	$name = join "_", $data[0],$data[1];
	$info{$name} = $_;
    }
    close INFILE;
    return %info;
}

#######################
#######################

sub print_info {

  printf FITFILE "%-25s %6s %6s %10s %10s %10s %10s %10s\n",
    "# Cluster","ObsID","BgdCCD","ObsCts","DeepCts","Obs/Qui","Deep/Qui","Obs/Deep";

}

#######################
#######################

sub extract_obsbgd {

  my($command,$cts,$exp,$rate);
  my($evtfile) = @_;

  # extract the background spectrum
  if ($uselocal eq "yes" ) {
    $command = "punlearn dmcopy; dmcopy \"${evtfile}\[energy=${emin}:${emax}\]\[sky=region($region)\]\" "
      ."temp_cts.fits clobber=yes verbose=$verb";
  } elsif ($addex eq "yes") {
    $command = "punlearn dmcopy; dmcopy \"${evtfile}\[energy=${emin}:${emax}\]\" "
      ."temp_cts.fits clobber=yes verbose=$verb";
  } else {
    $command = "punlearn dmcopy; dmcopy \"${evtfile}\[ccd_id=${bgccd}\]\[energy=${emin}:${emax}\]\" "
      ."temp_cts.fits clobber=yes verbose=$verb";
  }
  system($command);

  # query for the number of counts in the file
  $command = "punlearn dmlist; dmlist \"temp_cts.fits\[events\]\" counts outfile=obscts.log";
  system($command);

  # store those counts as a variable
  $cts = use_dmlist("obscts.log");
  unlink("obscts.log");

  # check that there are counts
  if ($cts <= 0) {
    print "## ERROR: ${obsid} ($name) no counts in observation\n";
    print ERR "${obsid}: no counts in observation\n";
    return -1;
  }

  # get the exposure time
  $exp = `dmkeypar ${evtfile} EXPOSURE; pget dmkeypar value`;
  chomp($exp);

  # return the count rate per chip
  $rate = $cts/$exp;

  unlink("temp_cts.fits");
  return $rate;
}

#######################
#######################

sub extract_deepbgd {

  my($command,$cts,$exp,$rate);
  my($bgfile) = @_;

  # extract the background spectrum
  if ($uselocal eq "yes" ) {
    $command = "punlearn dmcopy; dmcopy \"${bgfile}\[energy=${emin}:${emax}\]\[sky=region($region)\]\" "
      ."temp_cts.fits clobber=yes verbose=$verb";
  } elsif ($addex eq "yes") {
    $command = "punlearn dmcopy; dmcopy \"${bgfile}\[energy=${emin}:${emax}\]\" "
      ."temp_cts.fits clobber=yes verbose=$verb";
  } else {
    $command = "punlearn dmcopy; dmcopy \"${bgfile}\[ccd_id=${bgccd}\]\[energy=${emin}:${emax}\]\" "
      ."temp_cts.fits clobber=yes verbose=$verb";
  }
  system($command);

  # query for the number of counts in the file
  $command = "punlearn dmlist; dmlist \"temp_cts.fits\[events\]\" counts outfile=deepcts.log";
  system($command);

  # store those counts as a variable
  $cts = use_dmlist("deepcts.log");
  unlink("deepcts.log");

  # check that there are counts
  if ($cts == 0) {
    print "## ERROR: ${obsid} ($name) no counts in deep bgd\n";
    print ERR "${name} ${obsid} no counts in deep bgd\n";
    return -1;
  }

  # get the exposure time
  $exp = `punlearn dmkeypar; dmkeypar ${bgfile} EXPOSURE; pget dmkeypar value`;

  # return the count rate per chip
  $rate = $cts/$exp;

  unlink("temp_cts.fits");
  return $rate;
}

#######################
#######################

sub bgd_ratio {

  my($obsrate,$deeprate,$qbgd) = @_;

  my $bgdratio = $obsrate/$deeprate;
  my $oqratio = $obsrate/$qbgd;
  my $dqratio = $deeprate/$qbgd;

  # print out the info
  open(FITFILE,">>${Bin}/${logfile}");
  printf FITFILE "%-25s %6s %6s %10.4f %10.4f %10.4f %10.4f %10.4f\n",
    ${name},${obsid},${bgccd},${obsrate},${deeprate},${oqratio},${dqratio},${bgdratio};
  close FITFILE;
  return($bgdratio);

}

#######################
#######################

sub set_qbgd {
  my ($evtfile) = @_;
  my ($mode, $date, $year, $mon, $day, $per, $qid, $qbgd);

  # determine the quiescent background rate to use
  # find the obs date
  chomp($mode = `dmkeypar $evtfile DATAMODE ; pget dmkeypar value`);
  $date = `dmkeypar $evtfile DATE-OBS ; pget dmkeypar value`;
  @date = split("T",$date);
  $date = $date[0];
  @date = split("-",$date);
  $year = $date[0];
  $mon  = $date[1];
  $day  = $date[2];

  # determine the qbgd period to use
  # periods:
  # A: <= 1999-09-16
  # B: 1999-09-17 -> 2000-01-28
  # C: 2000-01-29 -> 2000-11-30
  # D: 2000-12-01 -> 2003-12-31
  # perform a logic test on date
  if ($year != 0) {
    if ($year <= 1999) {
      $per = "A" if ($mon < 9);
      $per = "A" if ($mon == 9 && $day <= 16);
      $per = "B" if ($mon > 9 || ($mon == 9 && $day > 16));
    } elsif ($year == 2000) {
      $per = "B" if ($mon == 1 && $day <= 28);
      $per = "C" if ($mon == 1 && $day > 28);
      $per = "C" if ($mon > 1 && $mon < 11);
      $per = "C" if ($mon == 11 && $day <= 30);
      $per = "D" if ($mon == 12);
    } elsif ($year > 2000) {
      $per = "D";
    }
  }
  $per = "Dvf" if ($per eq "D" && $mode eq "VFAINT");

  # read from the qbgd array
  $qid = "${per}${raw_id}";
  $qbgd = $qrate{$qid};
  return $qbgd;
}

#######################
#######################

sub use_dmlist {

  my($infile) = @_;
  my(@line,$value);

  open(FILE,$infile);
  while(<FILE>) {
    chomp;
    next if (/^\#/);
    next if (/^$/);
    s/^\s+//;  # trim leading whitespace
    s/\s+$//;  # trim trailing whitespace
    @line = split;
    $value = $line[0];
  }
  close FILE;
  return $value;
}

#######################
#######################

sub adj_deep {

    my($bgd,$obgd,$rate) = @_;

    # reverse the sense of rate
    $normrate = sprintf("%f",1.0/$rate);

    # get exposure time
    $ogbexp = `dmkeypar $bgd EXPOSURE; pget dmkeypar value`;
    chomp($ogbexp);
    $ogbexp = sprintf("%f",$ogbexp);

    # Update the background header with the EXPOSURE and BKGNORM keywords
    $nbexp = $ogbexp*$normrate;
    @keys = qw(EXPOSURE ONTIME LIVETIME);
    @files = ($bgd, $obgd);
    foreach $file (@files) {
	$command = "dmhedit $file filelist=none operation=add key=OGEXP value=$ogbexp datatype=float";
	system($command);
	$command = "dmhedit $file filelist=none operation=add key=BKGNORM value=$rate datatype=float";
	system($command);
	foreach $timekey (@keys) {
	    $command = "dmhedit $file filelist=none operation=add key=$timekey value=$nbexp datatype=float";
	    system($command);
	}
    }
}

#######################
#######################
