#! /usr/bin/perl -w
#
# NAME:
#     reprocess.pl
#
# PURPOSE:
#     Take raw level one event file and create new level
#     two event file.
#
# EXPLANATION:
#     This script assumes the following directory structure:
#     all pertinent Chandra data files are in a dir labeled with
#     the obsid, which is then in a $datadir,
#     e.g., for Obsid 2211, this script will look to:
#     $datadir/2211/
#
#     New files will be placed in the directory defined by the
#     variable $rootdir.
#
# CALLING SEQUENCE:
#     reprocess.pl <reference list>
#
# INPUTS:
#     <reference list> generated by query_cda.pl
#     Name        ObsID        X        Y   Rmax  MinCts        z   Nh20     Tx     Fe   Lbol  Chip    E_obs  Diff   Robs      Location                Txref
#     --             --      deg      deg    pix     cts       --  cm^-2    keV  solar 1d44es    --      keV    --    pix            --                   --
#     ABELL_0068   3250     3857     3790    700    2500   0.2550   4.90   7.30   0.30  14.36    i3   0.0000     y      0  /mnt/GIDEON/  2008A&A...482..451Z
#
# OUTPUTS:
#     new level one event file:           <obsid>_evt1.fits
#     new level two event file:           <obsid>_evt2.fits
#     Good time intervals file:           <obsid>_<chipid>_gti.fits
#     FITS file cleaned of flares:        <obsid>_clean.fits
#     Light curve FITS file:              <obsid>_lc.fits
#     Postscript of Light Curve:          <obsid>_lc.ps
#     FITS file with pt srcs excluded:    <obsid>_exclude.fits
#     Deep bgd for source chip:           <obsid>_bgevt.fits
#     Add'n deep bgd for off source:      <obsid>_<alt chip>_bgevt.fits
#
#######################
#######################
##   Main Program    ##
#######################
#######################

# check for ciao
die "## ERROR: CIAO is not loaded\n" unless ($ENV{'ASCDS_BIN'});

# check for ciao env loaded
use Cwd;
use FindBin qw($Bin);
use Getopt::Long;

# read the command line
GetOptions('evt:s'   => \$make_evt,
	   'clean:s' => \$clean_events,
	   'bgd:s'   => \$make_blank_bgd,
	   'abgd:s'  => \$make_addblank_bgd,
	   'rdir=s'  => \$rootdir,
	   'flare:s' => \$flarefile,
	   'lc:s'    => \$lcdir,
	   'verb:i'  => \$verb);

# explain
$usage = "usage: perl reprocess.pl\n".
    "              [--evt yes/no]\n".
    "              [--clean yes/no]\n".
    "              [--bgd yes/no]\n".
    "              [--abgd yes/no]\n".
    "              [--rdir <datadir>]\n".
    "              [--flare <flarefile>]\n".
    "              [--lc <lightcurves>]\n".
    "              [--verb 0-5]\n";
if (@ARGV != 1) {
    print "## ERROR: No reference file given.\n";
    die $usage;
}
unless ($rootdir) {
    print "## ERROR: No rootdir defined.\n";
    die $usage;
}
unless ($make_evt || $clean_events || $make_blank_bgd || $make_addblank_bgd) {
    print "## ERROR: You did not tell me to do anything.\n";
    die $usage;
}

# set defaults
$make_evt           = "no" unless ($make_evt);
$clean_events       = "no" unless ($clean_events);
$make_blank_bgd     = "no" unless ($make_blank_bgd);
$make_addblank_bgd  = "no" unless ($make_addblank_bgd);
$flarefile          = $ENV{'HOME'}."/research/redux/redux_info/flares.list";
$lcdir              = $ENV{'HOME'}."/research/redux/redux_info/lightcurves/";
$verb               = 1;

# reference array for all chip ids
%chip_id = ("i0" =>"0", "i1" =>"1", "i2" =>"2", "i3" =>"3", "s0"
	    =>"4", "s1" =>"5", "s2" =>"6", "s3" =>"7", "s4" =>"8",
	    "s5" =>"9");

# find the version of CALDB presently in use
`dmlist \"\$CALDB/docs/chandra/caldb_version/caldb_version.fits[cols caldb_ver]\" data,clean outfile=temp.dat`;
$caldb = &sub_use_dmlist("temp.dat");
unlink("temp.dat");
print "## STATUS: Your current version of the CALDB is: $caldb\n";

# find the version of CIAO presently in use
`dmlist \"\$CALDB/docs/chandra/caldb_version/caldb_version.fits[cols ciao_ver]\" data,clean outfile=temp.dat`;
$ciaover = &sub_use_dmlist("temp.dat");
unlink("temp.dat");
print "## STATUS: Your current version of CIAO is: $ciaover\n";

# read in the reference file
%refdata = &sub_get_data($ARGV[0]);

# go through each cluster and extract event, images
{
  foreach $key (sort keys %refdata) {

      # split up the data line
      @data = split(/\s+/,$refdata{$key});

      # get values specific to each cluster
      $name    = $data[0];
      $obsid   = $data[1];
      $fidx    = $data[2];
      $fidy    = $data[3];
      $rmax    = $data[4];
      $id      = $data[11];
      $datadir = $data[15];

      # write to log file
      print "## STATUS: Started $name (ObsId $obsid) ",scalar(localtime),"\n";

      # change directory
      chdir("$datadir/$obsid/");

      # make directory to store reprocessed and new files
      mkdir($rootdir,0777) unless (-d $rootdir);
      chdir($rootdir) || die "## $obsid: Cannot change to dir $rootdir\n";

      # figure out which detector is in use
      $instr = "s" if ($id =~ /^s/);
      $instr = "i" if ($id =~ /^i/);

      # get the asol file or files
      $asol = &sub_get_asolfile();

      # define file names	
      $newevt2   = "${obsid}_evt2.fits";
      $newbpix   = "${obsid}_bpix.fits";
      $lcfile    = "${obsid}_lc.fits";
      $cleanfile = "${obsid}_clean.fits";
      $exclreg   = "${obsid}_exclude.reg";
      $exclfile  = "${obsid}_exclude.fits";
      $chipfits  = "${obsid}_chipregs.fits";

      # empty the fail var per loop
      $fail = "";

      # generate new evt1 and evt2 files with updated calib info
      if ($make_evt eq "yes") {
	  $fail = &sub_make_evt($newevt2,$newbpix);
	  if ($fail eq "yes") {
	      $offender = "make_evt";
	      &sub_logerror($offender);
	      next;
	  }

	  # create a FITS file containing all the chip regions
	  &sub_make_regions($newevt2,$chipfits);
      }

      # set badpix file
      `punlearn ardlib.par; punlearn acis_set_ardlib`;
      `acis_set_ardlib $newbpix verb=0`;

      # clean bad times using the light curve
      $fail = &sub_clean_events($lcfile,$newevt2,$cleanfile) if (($clean_events eq "yes") || ($clean_events eq "y"));
      if ($fail eq "yes") {
	  $offender = "clean_events";
	  &sub_logerror($offender);
	  next;
      }

      # make blank sky background
      $fail = &sub_make_blank_bgd($exclfile) if ($make_blank_bgd eq "yes");
      if ($fail eq "yes") {
	  $offender = "make_blank_bgd";
	  &sub_logerror($offender);
	  next;
      }

      # make an additional blank background file for comparison of deep bgd and obs bgd rates      
      $fail = &sub_make_addblank_bgd($exclfile) if ($make_addblank_bgd eq "yes");
      if ($fail eq "yes") {
	  $offender = "make_addblank_bgd";
	  &sub_logerror($offender);
	  next;
      }

      # cleanup temp files that might have been created
      unlink <xsel*>;
      print "## STATUS: Finished $name (ObsId $obsid) ",scalar(localtime),"\n";
      chdir("$Bin");
  }
}

# CIAO and IDL use the DYLD_BIND_AT_LAUNCH environment variable.
print "## STATUS: Finished reprocessing ",scalar(localtime),"\n";
delete $ENV{'DYLD_BIND_AT_LAUNCH'};
exit 0;

#######################
#######################
##   Sub-Routines    ##
#######################
#######################

sub sub_get_info {
    my($file,$key) = @_;
    $value = `punlearn dmkeypar; dmkeypar ${file} $key; pget dmkeypar value`;
    chomp($value);
    $value =~ s/\s+//g;
    $value =~ s/\'//g;
    return $value;
}

#######################
#######################

sub sub_get_data {

    my($infile) = @_;
    my(@data,$name,%info);
    open(INFILE,$infile) || die "## ERROR: Cannot open $infile\n";
    while (<INFILE>) {
	chomp;
	next if (/^\#/);
	next if (/^$/);
	s/^\s+//;
	s/\s+$//;
	@data = split;
	$name = join "_", $data[0],$data[1];
	$info{$name} = $_;
    }
    close INFILE;
    return %info;
}

#######################
#######################

sub sub_make_evt {

    # run chandra_repro and creates new evt1 and new evt2 files
    my($newevt2,$newbpix) = @_;
    chdir("../");
    $command = "punlearn chandra_repro; chandra_repro indir=\.\/ outdir=\.\/ctemp root=${obsid} clob+ verbose=${verb}";
    system($command);

    # check that it worked or return an error
    if (-e "ctemp/${obsid}_repro_evt2.fits") {
	print "## STATUS: New evt2 file created: ${newevt2}\n";
    } else {
	return "yes";
    }

    # clean house
    $command = "mv -f ctemp/${obsid}_repro_evt2.fits ${rootdir}/$newevt2";
    system($command);
    $command = "mv -f ctemp/*bpix1.fits ${rootdir}/$newbpix";
    system($command);
    system("rm -rf ctemp");
    chdir($rootdir);
}

#######################
#######################

sub sub_clean_events {

    # input parameters
    my($lcfile,$evt2file,$outfile) = @_;

    # make sure event file exists
    unless (-e $evt2file) {
	print "## ERROR: Cannot find $evt2file\n";
	return "yes";
    }
    unless (-e $exclreg) {
	print "## ERROR: Cannot find $exclreg\n";
	return "yes";
    }

    # make directory to store light curves
    mkdir("$lcdir",0777) unless (-d "$lcdir");

    # local variables
    my($output,$gti,$total);
    my($nbins_bi) = 1037.12; # BI chips
    my($nbins_fi) = 259.28;  # FI chips
    my($psfile)  = "${obsid}_lc";
    my($pngfile) = "${obsid}_lc.png";
    my($gtifile) = "${obsid}_${id}_gti.fits";
    my($srcreg) = "${obsid}_clean.reg";

    # set bin size for fi, bi, or s3
    if (${id} eq "s1" || ${id} eq "s3") {
	$nbins = $nbins_bi;
    } else {
	$nbins = $nbins_fi;
    }
    
    # # make a source region using x, y, and rmax
    if (($fidx =~ /\./) || ($rmax <= 0.0)) {
    	print "## WARNING: Either the fiducial (x,y) coordinates are RA and Dec,\n";
    	print "##          or rmax is <= 0.0. You pretty much have to use a source\n";
    	print "##          free region for lc filtering, so you need to set (x,y) \n";
    	print "##          in phys coords and give me an rmax which is not zero.\n";
	print "## ERROR: Cannot remove source region for lightcurve filtering\n";
	return "yes";
    } else {
    	my $rout = $rmax/2.0;
    	open(SREG,">$srcreg");
    	printf SREG "circle(${fidx},${fidy},${rout})\n";
    	close SREG;
    }

    # delete old files
    unlink $gtifile if (-e $gtifile);
    unlink $lcfile  if (-e $lcfile);
    unlink $psfile  if (-e $psfile.'.ps');
    unlink $pngfile if (-e $pngfile);
    unlink $outfile if (-e $outfile);

    # make new event file excluding cluster region and use energy
    # range as given by Markevtich in the cookbook for appropriate
    # chip (BI or FI).
    if (${id} eq "s3") {
	$command = "punlearn dmcopy; dmcopy \"${evt2file}\[energy=2500:7000,ccd_id=7]\" "
	    ."tempclean1.fits clob+ verbose=$verb";
    } elsif (${id} eq "s1") {
	$command = "punlearn dmcopy; dmcopy \"${evt2file}\[energy=2500:6000,ccd_id=5]\" "
	    ."tempclean1.fits clob+ verbose=$verb";
    } else {
	if ($instr =~ "i") {
	    $command = "punlearn dmcopy; dmcopy \"${evt2file}\[energy=300:12000,ccd_id=0,1,2,3]\" "
		."tempclean1.fits clob+ verbose=$verb";
	} else {
	    $command = "punlearn dmcopy; dmcopy \"${evt2file}\[energy=300:12000,ccd_id=$chip_id{$id}]\" "
		."tempclean1.fits clob+ verbose=$verb";
	}
    }
    system($command);

    # make an event file cleaned of bright sources
    $command = "punlearn dmcopy; dmcopy \"tempclean1.fits\[exclude sky=region(${srcreg})]\" "
	."tempclean2.fits clob+ verbose=$verb";
    system $command;
    $command = "punlearn dmcopy; dmcopy \"tempclean1.fits\[exclude sky=region(${exclreg})]\" "
	."tempclean3.fits clob+ verbose=$verb";
    system $command;
    $tempevt = "tempclean3.fits";

    # make the lightcurve
    $command = "punlearn dmextract; dmextract infile=\"${tempevt}\[bin time=::${nbins}]\" "
	."outfile=$lcfile opt=ltc1 clob+ verbose=$verb";
    print "$command\n";
    system($command);

    # for light curves with strong flares the mean bgd rate must be set
    if (-e "${flarefile}") {
	open(FLAREFILE,"${flarefile}");
	while (<FLAREFILE>) {
	    chomp;
	    $line = $_;
	    next if (/^\#/);
	    next if (/^$/);
	    s/^\s+//;
	    s/\s+$//;
	    @a = split(/\s+/,$line);
	    $fobsid = $a[0];
	    $fmean  = $a[1];
	    if ($fobsid ne $obsid) {
		$chflare = "";
		next;
	    } else {
		$chflare = "mean=${fmean},\n";
		last;
	    }
	}
	close FLAREFILE;
    } else {
	$chflare = "";
    }

    # use get good time intervals and produce plot
    print "## STATUS: Running lightcurve cleaning\n";
    open(CHFILE,">chips.py") || return "yes";
    print CHFILE 'from lightcurves import *'."\n";
    print CHFILE "lc_clean(\"${lcfile}\", outfile=\"${gtifile}\", ${chflare} plot=True, pattern=\"none\", verbose=1)\n";
    print CHFILE "print_window(\"${psfile}\", \[\"fittopage\", True, \"clobber\", True, \"orientation\", \"landscape\"])\n";
    print CHFILE "exit\n";
    system("chips -n -b chips.py");
    
    # check that it worked
    if (-e $gtifile) {
	print "## STATUS: Light curve processing complete\n";
	print "## STATUS: Creating new event file ($outfile) from GTI info\n";
	system("dmcopy \"${evt2file}\[\@${gtifile}]\" $outfile clob+");

	# copy light curve to a dir
	$command = "cp -f ${psfile}.ps ${lcdir}/";
	system($command);
	print "## STATUS: Copied light curve ${psfile}.ps to $lcdir\n";
	unlink("tempclean1.fits");
	unlink("tempclean2.fits");
	unlink("chips.sl");
    } else {
	unlink("tempclean1.fits");
	unlink("tempclean2.fits");
	unlink("tempclean3.fits");
	unlink("chips.sl");
	return "yes";
    }

    # remove point sources from light curve cleaned events file
    print "## STATUS: Excluding sources from cleaned file.\n";
    $command = "dmcopy \"$outfile\[exclude sky=region($exclreg)]\" $exclfile clob+ verbose=$verb\n";
    system $command;
}

#######################
#######################

sub sub_make_regions {
    my($evtfile,$regfits) = @_;
    print "## STATUS: Creating FITS file $regfits containing defined chip boundaries.\n";
    $command = "punlearn skyfov ; skyfov $evtfile $regfits aspect=$asol kernel=FITS clob+ verbose=0";
    system($command);
}

#######################
#######################

sub sub_make_blank_bgd {

    my($evtfile) = @_;
    my($a,$bgdfile,@bgfiles,@pcadfiles,$pcad,
       @mergefiles,@rmfiles,$aim,$expt,$ont,$lvt);

    # define and clear filename
    my($bgevtfile) = "${obsid}_bgevt.fits";
    unlink $bgevtfile if (-e $bgevtfile);

    # get the bgd file from CALDB
    chomp(@bgfiles = `punlearn acis_bkgrnd_lookup; acis_bkgrnd_lookup ${evtfile}`);
    $bgdfile = join(",",@bgfiles);

    # only proceed if we have file(s)
    if ($bgdfile ne "") {

	# only do the following filter for vfaint mode
	$datamode = &sub_get_info($evtfile,"DATAMODE");

	# filter the background if status column exists
	$i = 0;
	undef @mergefiles;
	undef @rmfiles;
	foreach $a (@bgfiles) {

	    # check for vfaint mode
	    if ($datamode eq "VFAINT") {
		print "## STATUS: Data taken in VFAINT mode, filtering bgd...\n";
		$command = "punlearn dmcopy ; dmcopy \"${a}[status=0]\" temp.fits verbose=$verb clob+";
	    } else {
		$command = "cp ${a} temp.fits";
		
	    }
	    system($command);

	    # check the gain file used
	    my $evtgain = &sub_get_info($evtfile,"GAINFILE");
	    my $bgdgain = &sub_get_info("temp.fits","GAINFILE");
	    @bgdgain = split(/\//,$bgdgain);
	    $bgdgain = pop(@bgdgain);
	    if ($evtgain ne $bgdgain) {
		print "## WARNING: evt and bgd gains do not match!\n";
		print "## STATUS: Updating bgd gain file...\n";
		$command = "punlearn acis_process_events; acis_process_events infile=temp.fits outfile=temp2.fits"
		    ." acaofffile=NONE stop=\"none\" doevtgrade=no apply_cti=yes apply_tgain=no"
		    ." calculate_pi=yes pix_adj=NONE gainfile=\$CALDB/data/chandra/acis/det_gain/${evtgain}"
		    ." eventdef=\"\{s:ccd_id,s:node_id,i:expno,s:chip,s:tdet,f:det,f:sky,s:phas,l:pha,l:pha_ro,f:energy,l:pi,s:fltgrade,s:grade,x:status\}\""
		    ." verbose=0 clob+";
		system($command);
		unless (-e "temp2.fits") {
		    print "## ERROR: Updating the gain file failed.\n";
		    return "yes";
		}
		system(`mv -f temp2.fits temp.fits`);
	    }
	    system(`mv -f temp.fits ${i}.fits`);
	    push @mergefiles,"${i}.fits";
	    push @rmfiles,"${i}.fits";
	    $i++;
	}
	unlink("temp");
	$bgdfile = join(",",@mergefiles);

	# merge all the bgd files into one and add the PNT header keywords
	print "## STATUS: Merging backgrounds\n";
	$command = "punlearn dmmerge; dmmerge \"$bgdfile\" tempbgd.fits clob+ verbose=0";
	system($command);
	$command = "dmmakepar $evtfile evthdr.par clob+; grep \_pnt evthdr.par > evtpnt.par; dmreadpar evtpnt.par \"tempbgd.fits\[events\]\" clob+";
	system($command);

	# reproject event
	print "## STATUS: Reprojecting background\n";
	$command = "punlearn reproject_events; reproject_events infile=\"tempbgd.fits\" outfile=\"$bgevtfile\" aspect=\"$asol\" "
	    ."match=$evtfile random=0 verbose=0 clob+";
	system($command);
    } else {
	print "## ERROR: no bgd files found\n";
	return "yes";
    }
    unlink("tempbgd.fits");
    unlink("temp.fits");
    unlink("evthdr.par");
    unlink("evtpnt.par");
    unlink(@rmfiles);
    if (-e $bgevtfile) {
	return "no";
    } else {
	return "yes";
    }
}

#######################
#######################

sub sub_make_addblank_bgd {
    
    my($evtfile) = @_;
    my($bgdfile,@pcadfiles,$pcad);
    
    if ($instr eq "s") {
	@bgd_id = ("i2", "i3");
    } elsif ($instr eq "i") {
	@bgd_id = ("s2", "s3");
    } else {
	print "## ERROR: You've given me an unknown chip_id... sinner >:)\n";
	return "yes";
    }
    my $i = 0;
    my $check = "no";
    while ($i < 2 && $check ne "ok") {

	# isolate the input chip
	$isoid = "$bgd_id[$i]";
	$isoevt = "temp_${isoid}.fits";
	$command = "punlearn dmcopy; dmcopy \"${evtfile}\[ccd_id=$chip_id{$isoid}\]\" $isoevt clob+ verbose=$verb";
	system($command);
	
	# check that the chip exists, if not move to i3
	$command = "punlearn dmlist; dmlist \"${isoevt}[events]\" counts outfile=temp.log";
	system($command);
	
	# store those counts as a variable
	$cts = &sub_use_dmlist("temp.log");
	unlink("temp.log");

	# move to another chip if no counts
	if ($cts == 0) {
	    print "## STATUS: No counts on $isoid, moving to new chip\n";
	    unlink($isoevt);
	    $check = "no";
	    $i++;
	} else {
	    # check for a bgd file from CALDB
	    @bgdfile = `acis_bkgrnd_lookup ${isoevt}`;
	    if (@bgdfile) {
		chomp($bgdfile = $bgdfile[0]);
		print "## STATUS: Using $isoid\n";
		print "## STATUS: With bgd file $bgdfile\n";
		$check = "ok";
		last;
	    } else {
		print "## STATUS: No bgd file found for $isoid\n";
		unlink($isoevt);
		$check = "no";
		$i++;
	    }
	}
	if ($i == 2) {
	    print "## STATUS: No viable off source chip background to use\n";
	    unlink($isoevt);
	    return "yes";
	}
    }

    # proceed only if bgdfile exists, otherwise,
    my $dname = $bgdfile;
    $dname =~ s/\[.*?\]//g;
    if (-e $dname) {

	# single chip
	my $tempbgd = "bgevt_${isoid}.fits";
	$command = "punlearn dmcopy; dmcopy \"${bgdfile}[ccd_id=$chip_id{$isoid}]\" $tempbgd clob+ verbose=$verb";
	system($command);

	# reproject event
	my($xbgevtfile) = "x${obsid}_bgevt.fits";
	system("punlearn reproject_events");
	my($bgevtfile) = "${obsid}_${isoid}_bgevt.fits";
	unlink $bgevtfile if (-e $bgevtfile);
	$command = "reproject_events infile=\"${tempbgd}\" outfile=\"$bgevtfile\" "
	    ."aspect=\"$asol\" match=$isoevt random=0 mode=h verbose=$verb clob+";
	system($command);
	
	# clean up the temp file
	unlink $xbgevtfile;

	# check the datamode of the obs
	$datamode = &sub_get_info($evtfile,"DATAMODE");
	

	# filter the background if it's needed
	if ($datamode eq "VFAINT") {
	    print "## STATUS: Data taken in VFAINT mode, background needs check_vf_pha filter applied\n";
	    $command = "punlearn dmcopy; dmcopy \"${bgevtfile}[status=0]\" tempbgd.fits verbose=$verb clob+";
	    system($command);
	    system(`mv -f tempbgd.fits ${bgevtfile}`);
	}

	# check the gain file used
	my $evtgain = &sub_get_info($evtfile,"GAINFILE");
	my $bgdgain = &sub_get_info($bgevtfile,"GAINFILE");
	@bgdgain = split(/\//,$bgdgain);
	$bgdgain = pop(@bgdgain);
	if ($evtgain ne $bgdgain) {
	    print "## WARNING: evt and bgd gains do not match!\n";
	    print "## STATUS: Updating bgd gain file...\n";
	    $command = "punlearn acis_process_events; acis_process_events infile=${bgevtfile} outfile=tempbgd.fits"
		." acaofffile=NONE stop=\"none\" doevtgrade=no apply_cti=yes apply_tgain=no"
		." calculate_pi=yes pix_adj=NONE gainfile=\$CALDB/data/chandra/acis/det_gain/${evtgain}"
		." eventdef=\"\{s:ccd_id,s:node_id,i:expno,s:chip,s:tdet,f:det,f:sky,s:phas,l:pha,l:pha_ro,f:energy,l:pi,s:fltgrade,s:grade,x:status\}\""
		." verbose=0 clob+";
	    system($command);
	    unless (-e "temp2.fits") {
		print "## ERROR: Updating the gain file failed.\n";
		return "yes";
	    }
	    system(`mv -f tempbgd.fits ${bgevtfile}`);
	}

	# clean-up
	unlink($isoevt);
	unlink($tempbgd);
    } else {
	# if anything goes wrong report an error
	return "yes";
    }
}

#######################
#######################

sub sub_get_asolfile {

    # get the asol file for files
    my($curdir,@infile,$asol,@dir,@globlist);
    $curdir = cwd();

    # change to appropriate dir (they sometimes change the locations)
    @dir = qw(primary secondary);
    @infile = ();
    foreach $dir (@dir) {
	chdir "../$dir";
	@globlist =  <pcad*asol*.fits*>;
	@globlist = map { "../$dir/" . $_} @globlist if (@globlist);
	push @infile, @globlist;
	chdir $curdir;	
    }
    die "## ERROR: No $obsid asol files.\n" unless (@infile);
    $asol = join(",",@infile);

    # return the name(s)
    chdir($curdir);
    return $asol;
}

#######################
#######################

sub sub_logerror {
    my($offender) = @_;
    chdir("$Bin");
    open  ERRFILE,">>err_reprocess.log";
    print "## ERROR: reprocess.pl failure in $offender (ObsID $obsid) at ",scalar(localtime),"\n";
    print ERRFILE "${obsid} # FAILURE: reprocess.pl; $offender; ",scalar(localtime),"\n";
    close ERRFILE;
}

#######################
#######################

sub sub_use_dmlist {
    my($infile) = @_;
    my(@line,$value);
    open(FILE,$infile);
    while(<FILE>) {
	chomp;
	next if (/^\#/);
	next if (/^$/);
	s/^\s+//;
	s/\s+$//;
	@line = split;
	$value = $line[0];
    }
    close FILE;
    return $value;
}

#######################
#######################
#
#	    # check for status column
#	    unlink("temp");
#	    system("punlearn dmlist ; dmlist \"$a\[cols status\]\" opt=data rows=1 cells=1 outfile=temp verbose=0");
#	    if (-e "temp") {
#		if ($datamode eq "VFAINT") {
#		    print "## STATUS: Data taken in VFAINT mode and status exists, filtering bgd...\n";
#		    $command = "punlearn dmcopy ; dmcopy \"${a}[status=0]\" temp.fits verbose=$verb clob+";
#		    system($command);
#		    $command = "punlearn dmcopy ; dmcopy \"temp.fits[cols -status]\" temp2.fits verbose=$verb clob+; mv -f temp2.fits temp.fits";
#		    system($command);
#		} else {
#		    print "## STATUS: Data taken in FAINT mode no filtering required.\n";
#		    $command = "punlearn dmcopy ; dmcopy \"${a}[cols -status]\" temp.fits verbose=$verb clob+";
#		    system($command);
#		}
#	    } else {
#		print "## STATUS: ignore the above error, it's okay.\n";
#		$command = "cp ${a} temp.fits";
#		system($command);
#	    }
#
#######################
#######################

