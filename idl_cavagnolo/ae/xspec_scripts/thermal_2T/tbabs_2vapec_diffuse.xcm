# XSPEC script to fit a thermal plasma model and a nuisance celestial background model.
# The data consist of TWO observed spectra, from a diffuse object and 
# a sky region, each with an instrumental background spectrum obtained 
# from "stowed" data sets.
#
# THE ARFS FOR THE TWO REGIONS MUST BE SCALED (UP) BY AN APPROPIRATE FIELD OF VIEW AREA
# SO THAT HERE WE ARE MODELING SURFACE BRIGHTNESS, RATHER THAN FLUX IN THE APERTURE.
# See the ACIS Extract manual.
# With the field of view already calibrated out of the data sets, this script does NOT
# perform any scaling of the nuisance celestial background model between the two 
# data sets!!!

# THIS SCRIPT REQUIRES XSPEC 12!

set version "\$Id: tbabs_2vapec_diffuse.xcm,v 1.1 2008-10-15 19:37:32 cavagnolo Exp $"
set date_value [ exec date ]
puts "[ exec hostname ] $date_value $version"

# ACIS Extract is expected to prepend statments like the following:
# set obj_spectrum_filename   "green_grp3.0.pi"
# set sky_spectrum_filename   "bkg_diffuse_grp3.0.pi"
# set obj_ignore_spec         "1,92"
# set sky_ignore_spec         "1,13"
# set model_name              "grp3.0_tbabs_vapec_diffuse"
# set c_stat_flag             0
# set src_cnts                4752
# set cplinear_energies       {0.5 1.0 1.5 2.0 3.0 4.0 5.0 6.0 7.0 8.0}
# set model_directory         "/users/research/patb/TARA/code/ae/xspec_scripts"
# set interactive_flag        0


set xs_return_result 1
set tcl_precision 12
autosave off

# IMPORTANT NOTE:
# "OTHER MODEL" will mark sections (separated by blank lines) that
# must be changed if you rewrite this script with your own model

# USER may change boolean command echoing, useful for debugging.
set Echo_Mode 0 
set xs_echo_script $Echo_Mode

# USER may change the chatter level, useful for debugging, ranges from 0 to 25 
set Chatter_Level 10
chatter $Chatter_Level

# To omit execution of "error" commands (which sometimes hang xspec):
#set skip_errors 1
# OR, to compute parameter errors:
set skip_errors 0

# "OTHER MODEL"
# USER may change initial parameters
# Include digits after the decimal to avoid string-type FITS keyword.
set kT0_min   0.1
set kT0       0.5
set kT0_max  15.0

set kT20_min  0.4
set kT20      2.0
set kT20_max 15.0

set nH0_min   0.01
set nH0       1.0
set nH0_max 100.0

set He0  1.0  
set  C0  1.0  
set  N0  1.0  
set  O0  0.75 
set Ne0  1.17 
set Mg0  0.39 
set Al0  1.0  
set Si0  0.57 
set  S0  0.55 
set Ar0  0.78 
set Ca0  0.29 
set Fe0  0.35 
set Ni0  0.32 

# A reasonable initial value for the "norm" parameter helps prevents fits from
# running off into the weeds.
set norm0  1E-6
set norm20 1E-6



# USER may change the confidence intervals used in calculating
# errors on fit parameters and errors on fluxes.
# Beware that you must express the desired parameter confidence intervals
# in units of "sigma" and you must express the desired flux
# confidence intervals in units of percent probability.
# For 2-sided confidence intervals on a Gaussian distribution the 
# relationship between these two representations is given in a table
# in the ahelp page for the Sherpa "projection" command, and in 
# Section 2.2 of the manual for XSPEC12.
# That table is shown below for convenience:
#   1.0 -sigma = 68%
#   1.65-sigma = 90%
#   2.0 -sigma = 95.5%
#   2.57-sigma = 99.0%
#   3.0 -sigma = 99.7%

# confidence intervals for fit parameters (in units of sigma)
# Always use a decimal point!
set Conf_Level_Par 1.65

# confidence intervals for flux estimates (in units of %)
set Conf_Level_Flux 90

# USER may change EbandLo, EbandHi, FluxName and Number_Runs
# for calculating fluxes and their errors over interested
# energy bands. Right now 3 bands are used: (0.5-2),(2-8),(0.5-8).
set EbandLo {0.5 2 0.5}
set EbandHi {2 8 8}
# Notice two types of flux will be calculated, the second
# one (marked with c) is corrected for column density.
# To write spectral results into fits file properly
# flux names should not have more than 8 characters.
set FluxName {F0p5_2 F2_8 F0p5_8 Fc0p5_2 Fc2_8 Fc0p5_8}
set Number_Runs 100


# set some other vars
set model_savfl  "model.xspecsav"
set model_fitsfl "model.fits"
set temp_headfl  "z_head.txt"
setplot energy
query yes


# AE CUSTOMIZATIONS are inserted here!!


# We will eventually be working with two "XSPEC sources".
# Source #1 will be our astrophysical model, tbabs(vapec), passed through its ACIS response.
# Source #2 will be our observed sky model, cplinear, passed through its ACIS response.
# Our diffuse object spectrum will be modeled by Source #1 + Source #2, and
# our sky spectrum will be modeled by only Source #2.
 
# Load the "object" (obj) spectrum as spectrum #1 in data group #1.
data 1:1 $obj_spectrum_filename

# Ignore some channels.
ignore 1:$obj_ignore_spec
ignore bad

# Save the names of the RMF, and ARF.
set obj_respfile [string trim [tcloutr response 1]]
if { $obj_respfile eq "" } { set obj_respfile "none" }  

set obj_arffile [string trim [tcloutr arf 1]]
if { $obj_arffile eq "" } { set obj_arffile "none" }  


# Load sky spectrum as spectrum #2 in data group #2.
data 2:2 $sky_spectrum_filename

# Ignore some channels.
ignore 2:$sky_ignore_spec
ignore bad

# Save the names of the RMF, and ARF.
set sky_respfile [string trim [tcloutr response 2]]
if { $sky_respfile eq "" } { set sky_respfile "none" }  

set sky_arffile [string trim [tcloutr arf 2]]
if { $sky_arffile eq "" } { set sky_arffile "none" }  


# Detach the sky spectrum (spectrum #2) from the stellar model (source #1).
response 1:2 none

# Create a "source #2", which is going to be our cplinear sky model.
# Tie it to the sky spectrum (#2) through an RMF and ARF.
response 2:2 $sky_respfile
arf      2:2 $sky_arffile

# Load and create a continuous piecewise-linear sky model.
# We used "load" instead of "lmod" because the latter requires that the 
# user have write permission to the model directory.
set platform "[exec uname -s]_[exec uname -p]"
switch $platform {
  Darwin_i386    {load $model_directory/Darwin_i386/libacis_extract.dylib}
  Darwin_powerpc {load $model_directory/Darwin_powerpc/libacis_extract.dylib}
  Linux_unknown  {load $model_directory/Linux_unknown/libacis_extract.so}
  SunOS_sparc    {load $model_directory/SunOS_sparc/libacis_extract.so}
  default {tclexit 97}
}
set sky_norm_parnum 21

model 2:sky cplinear & /*

for {set ipar 1} {$ipar <= 10} {incr ipar} {
  newpar sky:$ipar [lindex $cplinear_energies [expr $ipar-1]]
}


# In order to get reasonable starting parameter values for our cplinear model
# later when we simultaneously fit source and sky spectra, 
# we need to fit the sky spectrum alone.
# We set "delta" component of the free parameters to be small compared to the parameter values.
xset delta 0.01
query yes

# Note that the rate* and "norm" parameters are degenerate.  
# For this initial fit we then find a rough normalization so the rate* parameters
# will tend towards values near 1 (for human readability).
# Then we freeze the normalization and fit for the rate* parameters.
renorm
freeze sky:$sky_norm_parnum
thaw   sky:11-20

chatter 9
for {set i 1} {$i <= 1} {incr i} { 
  fit 1000
}
chatter $Chatter_Level 

# We assume that XSPEC's fitting engine would like the "norm" parameter free during
# the main fit below that uses both diffuse object and sky data.
# Thus, we will thaw "norm" and freeze the largest of the "rate" parameters.
set largest_parnum 1
set largest_parval 0
set numpar [tcloutr modpar sky]
for {set ipar 1} {$ipar <= $numpar} {incr ipar} {
  # Skip "scale" parameters, which do not have "delta" values.
  if {[scan [tcloutr param sky:$ipar] "%f %f" par_value par_delta] == 1} {continue}
  if {$par_value > $largest_parval} {
    set largest_parnum $ipar
    set largest_parval $par_value
  }
}
freeze sky:$largest_parnum
thaw   sky:$sky_norm_parnum


# Interact with observer if desired.
if {$interactive_flag} {
  cpd /XW
  plot ldata resid
  puts "\nInitial fit to sky spectrum is shown.\nType 'c' to continue with script ...\n\n"
  interact
}

# We establish a connection between the diffuse object spectrum (#1) and the
# cplinear sky model (Source #2) through its RMF and ARF.
response 2:1 $obj_respfile
arf      2:1 $obj_arffile
show data
  
 
# Finally, we have to link the parameters between the two instances of cplinear.
# Discussions with Craig Gordon did not reveal any other way to do this in v12.3.1.
# The auto-linkage of parameters in two cplinear models occurs only if there are 
# two spectra with responses linked to the model when it is constructed.  
# But that is not useful in this context because we need at some point to have
# only the sky data linked to the sky model, so a good initial fit can be done.
newpar sky:32 = sky:11
newpar sky:33 = sky:12
newpar sky:34 = sky:13
newpar sky:35 = sky:14
newpar sky:36 = sky:15
newpar sky:37 = sky:16
newpar sky:38 = sky:17
newpar sky:39 = sky:18
newpar sky:40 = sky:19
newpar sky:41 = sky:20
newpar sky:[expr 2*$sky_norm_parnum] = sky:$sky_norm_parnum


if {$c_stat_flag} {
  statistic cstat
} else {
  # USER may change the weighting of chi statistics as
  # an alternative approach when there are few counts per group.
  # Available methods are:
  # "standard", "gehrels", "churazov", "model" 
  #
  # Note: if you change weighting method then do not forget to change
  # the name of this xspec script to make it unique,
  # then later you can compare spectral fit results
  # of different statistics and/or different weight methods.
  set Weighting_Method "standard"
  weight $Weighting_Method
}

# "OTHER MODEL"
# Create an "object" model attached to "XSPEC source #1".
#
# It's convenient to build the object model here, AFTER the sky model is sorted,
# for several reasons:
# * It eliminates some "response" and "arf" commands, clarifying the scipt..
# * If we set up a 2-component stellar model with linked abundances and then
#   have to issue "response none" to deal with the sky model then the linked
#   parameters become unlinked.
#
# We use the observer's parameter ranges as "soft" limits in the model, 
# leaving the "hard" limits at their wider default values.  
# This allows poorly constrained fits to exceed the soft limits; we can
# detect that during analysis of the fit results and identify such fits
# as bad.
#
abund wilm
model 1:obj tbabs(vapec+vapec) & /* 

set param_number(nH)        1
set param_number(kT)        2
set param_number(He)        3
set param_number(C)         4
set param_number(N)         5
set param_number(O)         6
set param_number(Ne)        7
set param_number(Mg)        8
set param_number(Al)        9
set param_number(Si)       10
set param_number(S)        11
set param_number(Ar)       12
set param_number(Ca)       13
set param_number(Fe)       14
set param_number(Ni)       15
set param_number(norm)     17
set param_number(kT2)      18
set param_number(norm2)    33

# Assign initial value to each parameter.
foreach param_name [array names param_number] {
  eval newpar obj:$param_number($param_name) $${param_name}0
}

# 2008  The default hard upper limit on kT in the vapec model is larger than the model
# will accept, so below we explicitly set it to 60 keV.
newpar obj:$param_number(nH)  $nH0  ,,, $nH0_min  $nH0_max 
newpar obj:$param_number(kT)  $kT0  ,,, $kT0_min  $kT0_max  60.0
newpar obj:$param_number(kT2) $kT20 ,,, $kT20_min $kT20_max 60.0

# Link abundances between the two vapec models.
newpar obj:19 = obj:3
newpar obj:20 = obj:4
newpar obj:21 = obj:5
newpar obj:22 = obj:6
newpar obj:23 = obj:7
newpar obj:24 = obj:8
newpar obj:25 = obj:9
newpar obj:26 = obj:10
newpar obj:27 = obj:11
newpar obj:28 = obj:12
newpar obj:29 = obj:13
newpar obj:30 = obj:14
newpar obj:31 = obj:15
newpar obj:32 = obj:16


if {$c_stat_flag} {
  # As of v12.3.1 XSPEC's renorm command, run automatically when "fit" is run,   
  # will mess up the normalization of the sky model we established earlier.
  # Thus we need to do some work to establish a good initial normalization for
  # the stellar model, and then disable these automatic renorms.
  freeze sky:11-21
  freeze obj:$param_number(nH) obj:$param_number(kT)
  fit  100
  renorm none
  thaw   sky:11-21
  thaw   obj:$param_number(nH) obj:$param_number(kT)
  freeze sky:$largest_parnum
  show model
}  


# If observer specifies a null range for a parameter then freeze it.
if {$nH0_min  >= $nH0_max}  {eval freeze obj:$param_number(nH)}
if {$kT0_min  >= $kT0_max}  {eval freeze obj:$param_number(kT)}
if {$kT20_min >= $kT20_max} {eval freeze obj:$param_number(kT2)}

# get & check D.O.F.
scan [tcloutr dof] "%d" dof_value
if {$dof_value < 1} {
  puts "DOF < 1; fit aborted"
  tclexit 98
} 


# We set "delta" component of the free parameters to be small compared to the parameter values.
xset delta 0.01

# Interact with observer if desired.
if {$interactive_flag} {
  show model
  puts "\nInitial model (before fit) is shown.\nFit by hand, then type 'c' to continue with script ...\n\n"
  interact
} else {
  # Fit multiple times to be sure ...
  for {set i 1} {$i <= 2} {incr i} { 
      fit 1000
  }
}


# get D.O.F. again since observer may have changed it.
scan [tcloutr dof] "%d" dof_value

# Save parameters to variables..
foreach param_name [array names param_number] {
  scan [eval tcloutr param obj:$param_number($param_name)] "%f" $param_name  
}


# create a save file for the model only for use if the error calculation below is aborted.
set flag_exists [file exists $model_savfl]
if {$flag_exists == 1} {
  file delete $model_savfl  
}
save model $model_savfl

# Show the the best fit parameters in the log so we can see how
# the fit wandered during execution the error commands.
chatter 10
show par
show fit
chatter $Chatter_Level 



puts "Step 3:  Error Calculations"
# "OTHER MODEL"
# If any of the parameters are out of range, then do not attempt error estimation.
if { $nH  < $nH0_min  || $nH  > $nH0_max  || \
     $kT2 < $kT20_min || $kT2 > $kT20_max || \
     $kT  < $kT0_min  || $kT  > $kT0_max     } {
  puts "Parameter limits violated after fit; skipping error estimation."
  set skip_errors 1
}


if {! $skip_errors} {
  # "OTHER MODEL"
  # calculate parameter errors
  #
  # The square relationship between confidence level sigma desired and the 
  # corresponding change in chi^2 is described in Section 2.1.1 of the 
  # XSPEC version 11 manual
  # and in ahelp page for the Sherpa "projection" command.
  set delta_chi [expr $Conf_Level_Par * $Conf_Level_Par]

  # We seem to recall that a single error command for all three pars led to some
  # trouble, but we can't recall the details.. 
  # Let's gamble that this is now fixed so we can avoid writing a loop here.
  #
  # You really want "query yes" mode when "error" is executed so that it will
  # restart the search for errors after new best fits are found.
  query yes
  if [catch {error $delta_chi obj:$param_number(nH) obj:$param_number(kT) obj:$param_number(norm) obj:$param_number(kT2) obj:$param_number(norm2)}] {
    puts "Error command failed to execute; reverting to original fit"
    set skip_errors 1
  } else {
    # Error calculation sucessful; get parameters, errors, flags, and statistics

    # Save parameters to variables..
    foreach param_name [array names param_number] {
      scan [eval tcloutr param obj:$param_number($param_name)] "%f" $param_name  
    }

    scan [tcloutr stat] "%f" stat_value

    scan [tcloutr error obj:$param_number(nH)]    "%f %f %s" nh_err_low    nh_err_high    nh_err_stat
    scan [tcloutr error obj:$param_number(kT)]    "%f %f %s" kt_err_low    kt_err_high    kt_err_stat
    scan [tcloutr error obj:$param_number(norm)]  "%f %f %s" norm_err_low  norm_err_high  norm_err_stat
    scan [tcloutr error obj:$param_number(kT2)]   "%f %f %s" kt2_err_low   kt2_err_high   kt2_err_stat
    scan [tcloutr error obj:$param_number(norm2)] "%f %f %s" norm2_err_low norm2_err_high norm2_err_stat
  }

  # If any of the parameters are out of range, then back out of the error estimation
  # since there is a good chance the parameters were fine after the original fit.
  if { $nH  < $nH0_min  || $nH  > $nH0_max  || \
       $kT2 < $kT20_min || $kT2 > $kT20_max || \
       $kT  < $kT0_min  || $kT  > $kT0_max     } {
    puts "Parameter limits violated after error search; reverting to original fit."
    set skip_errors 1
  }

  if {$skip_errors} {
    # If we're abandoning the error calculation then revert to the saved model.
    eval @$model_savfl

    # A "fit" command is required here so that a valid fit exists to support lots of
    # other work below, e.g. flux commands.
    # And I think loading the save file might turn off the "query yes" we had set up.
    fit
    query yes

    scan [tcloutr stat] "%f" stat_value
  };

  chatter 10
  show par                                 
  show fit
  chatter $Chatter_Level   
};  # calculate parameter errors

if {$skip_errors} {
  set nh_err_stat    'skipped'
  set kt_err_stat    'skipped'
  set norm_err_stat  'skipped'
  set kt2_err_stat   'skipped'
  set norm2_err_stat 'skipped'
  set nh_err_high    0.0
  set kt_err_high    0.0
  set norm_err_high  0.0
  set kt2_err_high   0.0
  set norm2_err_high 0.0
  set nh_err_low     0.0
  set kt_err_low     0.0
  set norm_err_low   0.0
  set kt2_err_low    0.0
  set norm2_err_low  0.0
}

# Save parameters to variables..
foreach param_name [array names param_number] {
  scan [eval tcloutr param obj:$param_number($param_name)] "%f" $param_name  
}


# create a complete save file for the final fit
set flag_exists [file exists $model_savfl]
if {$flag_exists == 1} {
  file delete $model_savfl  
}
save all $model_savfl



if {$c_stat_flag} {
  set       ps_filename "icounts.ps"
  scan [tcloutr stat] "%f" cstat_result
  set stat_print [format "Cstat=%.0f" $cstat_result]
  setplot command LAbel  Y  normalized integrated counts
  plot icounts residual

  # We think the cumulative spectrum is a more informative plot for weak
  # sources than the "setplot rebin" approach.  The old commands
  # remain below for reference:

  # see help info for rebin
  # We'll set Max_Nbins to just over half the typical number of "noticed" channels
  # (514) so that in the dim case we get two ~even sized bins.
  # And I guess we'll show Gehrels errors (option "poiss-1").
  # We can't tune Min_Signif to get a specific number of counts per bin
  # because the error term in Min_Signif includes background errors.
# set Max_Nbins 260
# set Min_Signif 2.0
# setplot rebin $Min_Signif $Max_Nbins -1 poiss-1
# plot ldata residual
} else {
  set       ps_filename "ldata.ps"
  scan [tcloutr stat] "%f" chi_squared
  set red_chi_squared [expr $chi_squared/$dof_value]
  set stat_print [format "\\gx\\d\\gn\\u\\u2\\d=%.2f" $red_chi_squared]
  setplot command LAbel  Y  Counts sec\\\u-1 \\\d keV\\\u-1\\\d
  plot ldata delchi
}

# "OTHER MODEL"
# make a postscript image of spectra 
scan [eval tcloutr param obj:$param_number(nH)] "%f %f" par_value par_delta 
set is_frozen [expr $par_delta < 0]                                                                        
if $is_frozen {
  set Nh_print [format "N\\dH\\u={%.3g}" $nH]
} else {
  set Nh_print [format "N\\dH\\u=%.3g" $nH]
}

scan [eval tcloutr param obj:$param_number(kT)] "%f %f" par_value par_delta 
set is_frozen [expr $par_delta < 0]                                                                        
if $is_frozen {
  set kT_print [format "kT={%.3g}" $kT]
} else {
  set kT_print [format "kT=%.3g" $kT]
}

scan [eval tcloutr param obj:$param_number(kT2)] "%f %f" par_value par_delta 
set is_frozen [expr $par_delta < 0]                                                                        
if $is_frozen {
  set kT2_print [format "kT={%.3g}" $kT2]
} else {
  set kT2_print [format "kT=%.3g" $kT2]
}

if [info exists src_cnts] {
  set src_cnts_print [format ", SRC_CNTS=%d" $src_cnts]
} else {
  set src_cnts_print ""
}

setplot command FONT Roman
setplot command TIME OFF
setplot command WIN      1
setplot command viewport 0.12 0.1 0.99 0.9
setplot command LAbel Top $Nh_print, $kT_print, $kT2_print, ${stat_print}${src_cnts_print}
setplot command LAbel File [file tail [tcloutr filename 1]]
#setplot command Rescale Y1 7.E-6 4.E-2
setplot add

setplot command WIN      2
setplot command viewport 0.12 0.1 0.99 0.8
#setplot command Yaxis  3
#if {$c_stat_flag == 0} {
#  setplot command Rescale    Y2 -3 3
#}
setplot command LAbel  X  Energy (keV)

setplot command WIN  ALL
# A CSize of 1.5 causes the title to be cut off.
# Shrinking the viewport in the X direction is needed to prevent the Y axis
# label from being cut off.
setplot command CSize 1.4
setplot command Rescale x 0.5 8
setplot command LWidth 3
plot
cpd $ps_filename/cps
plot
cpd none

# output info to xspec.log
# log none does not actually close the pipe
# so use copy
log z_temp_xspec.log
show all
log none
file copy -force z_temp_xspec.log xspec.log
file delete z_temp_xspec.log

# "OTHER MODEL" (for example add newpar if want to correct for second NH, otherwise do not edit)
# calculate interested fluxes and errors

set BandNum [llength $EbandLo]
# retrieve flux info and log. flux error info to temp file
for {set ii 0} {$ii <= [expr $BandNum*2-1]} {incr ii} {
  if {$ii == $BandNum} {
    # USER may add more newpar commands here.  
    # Correct for (NH) column density
    newpar obj:$param_number(nH) 0. 0.001 0. 0. $nH0_max $nH0_max 
  }
  
  if {$ii < $BandNum} {
    flux [lindex $EbandLo $ii] [lindex $EbandHi $ii] err $Number_Runs $Conf_Level_Flux
  } else {
    set iiii [expr $ii-$BandNum]
    flux [lindex $EbandLo $iiii] [lindex $EbandHi $iiii] err $Number_Runs $Conf_Level_Flux
  }
  # Retrieve the flux information for the object (spectrum #1).
  # The first set of six values are for "source" #1, the object model.
  # The second set of six values are for "source" #2, the cplinear sky model (if used).
  scan [tcloutr flux 1] "%f %f %f" flux flux_low flux_high
  eval set [lindex $FluxName $ii]  $flux
  eval set [lindex $FluxName $ii]L $flux_low
  eval set [lindex $FluxName $ii]U $flux_high
}



# "OTHER MODEL" (only change the last puts line)
# add flux and error info to xspec.log
set fileid [open xspec.log a]
for {set ii 0} {$ii <=[expr $BandNum*2-1]} {incr ii} {
  if {$ii < $BandNum} {
    set cmd "puts \$fileid \"Flux([lindex $EbandLo $ii]-[lindex $EbandHi $ii]):"  
  } else {
    set iii [expr $ii-$BandNum]
    set cmd "puts \$fileid \"Flux_corr([lindex $EbandLo $iii]-[lindex $EbandHi $iii]):"
  }
  set cmd "$cmd \$[lindex $FluxName $ii]  ${Conf_Level_Flux}% conf_range: (\$[lindex $FluxName $ii]L -"
  set cmd "$cmd \$[lindex $FluxName $ii]U)\""
  eval $cmd  
}
puts $fileid "$Conf_Level_Par sigma conf_ranges for Nh|kT|kT2:($nh_err_low - $nh_err_high)|($kt_err_low - $kt_err_high)|($kt2_err_low - $kt2_err_high)"
close $fileid

# "OTHER MODEL"
# prepare output for fits file
scan [tcloutr noticed 1] "%d-%d" chnl_low chnl_high

set fileid [open $temp_headfl w]
  puts $fileid "XTENSION=BINTABLE   /binary table extension"
  puts $fileid "EXTNAME=$model_name /name of this binary table"
  puts $fileid "DATE='$date_value'  / Date of model"
  puts $fileid "VERSION='$version'  / Script version"
  
  puts $fileid "nH0_MIN=$nH0_min    / \[1.e22 cm-2\] Minimum value for column density"
  puts $fileid "nH0=$nH0            / \[1.e22 cm-2\] Initial value of column density"
  puts $fileid "nH0_MAX=$nH0_max    / \[1.e22 cm-2\] Maximum value for column density"
  puts $fileid "KT0_MIN=$kT0_min    / \[keV\] Minimum value for temperature"
  puts $fileid "KT0=$kT0            / \[keV\] Initial value of temperature"
  puts $fileid "KT0_MAX=$kT0_max    / \[keV\] Maximum value for temperature"
  puts $fileid "kT20=$kT20          / \[keV\] Initial value of temperature"
  puts $fileid "kT20_MIN=$kT20_min  / \[keV\] Minimum value for temperature"
  puts $fileid "kT20_MAX=$kT20_max  / \[keV\] Maximum value for temperature"
  
  puts $fileid "CHNL_LOW=$chnl_low  / Low channel used"
  puts $fileid "CHNL_HI=$chnl_high  / High channel used"
  puts $fileid "DOF=$dof_value      / Degree of freedom"
  if {$c_stat_flag} {
    puts $fileid "CSTAT=$cstat_result / C-statistic"
  } else {
    puts $fileid "CHI_SQR=$red_chi_squared / Reduced chi-squared"
  } 
  puts $fileid "NH       =$nH             / \[1.e22 cm-2\] Derived column density"
  puts $fileid "NH_ERRU  =$nh_err_high    / \[1.e22 cm-2\] Column $Conf_Level_Par sigma upper limit"
  puts $fileid "NH_ERRL  =$nh_err_low     / \[1.e22 cm-2\] Column $Conf_Level_Par sigma lower limit"
  puts $fileid "NH_ERRST =$nh_err_stat    / Flag indicating problems with error calculation"
  puts $fileid "KT       =$kT             / \[keV\] Derived temperature"
  puts $fileid "KT_ERRU  =$kt_err_high    / \[keV\] Temperature $Conf_Level_Par sigma upper limit"
  puts $fileid "KT_ERRL  =$kt_err_low     / \[keV\] Temperature $Conf_Level_Par sigma lower limit"
  puts $fileid "KT_ERRST =$kt_err_stat    / Flag indicating problems with error calculation"
  puts $fileid "NORM     =$norm           / Derived normalization"
  puts $fileid "NORMERRU =$norm_err_high  / Normalization $Conf_Level_Par sigma upper limit"
  puts $fileid "NORMERRL =$norm_err_low   / Normalization $Conf_Level_Par sigma lower limit"
  puts $fileid "NORMERRS =$norm_err_stat  / Flag indicating problems with error calculation"
  puts $fileid "KT2      =$kT2            / \[keV\] Derived temperature"
  puts $fileid "KT2_ERRU =$kt2_err_high   / \[keV\] Temperature $Conf_Level_Par sigma upper limit"
  puts $fileid "KT2_ERRL =$kt2_err_low    / \[keV\] Temperature $Conf_Level_Par sigma lower limit"
  puts $fileid "KT2_ERRST=$kt2_err_stat   / Flag indicating problems with error calculation"
  puts $fileid "NORM2    =$norm2          / Derived normalization"
  puts $fileid "NOR2ERRU =$norm2_err_high / Normalization $Conf_Level_Par sigma upper limit"
  puts $fileid "NOR2ERRL =$norm2_err_low  / Normalization $Conf_Level_Par sigma lower limit"
  puts $fileid "NOR2ERRS =$norm2_err_stat / Flag indicating problems with error calculation"

  puts $fileid "He=$He / abundance"
  puts $fileid " C= $C / abundance"
  puts $fileid " N= $N / abundance"
  puts $fileid " O= $O / abundance"
  puts $fileid "Ne=$Ne / abundance"
  puts $fileid "Mg=$Mg / abundance"
  puts $fileid "Al=$Al / abundance"
  puts $fileid "Si=$Si / abundance"             
  puts $fileid " S= $S / abundance"
  puts $fileid "Ar=$Ar / abundance"
  puts $fileid "Ca=$Ca / abundance"
  puts $fileid "Fe=$Fe / abundance"
  puts $fileid "Ni=$Ni / abundance"
 
  # Record frozen state of parameters.
  foreach param_name [array names param_number] {
    scan [eval tcloutr param obj:$param_number($param_name)] "%f %f" par_value par_delta 
    
    if {$par_delta < 0} {
      set is_frozen "T"
    } else {
      set is_frozen "F"
    }

    eval puts $fileid \"${param_name}_fz=$is_frozen / parameter is frozen\"
  }

  set units "/ \\\[ergs cm-2 s-1\\\]"
  for {set ii 0} {$ii <=[expr $BandNum*2-1]} {incr ii} {
    if {$ii < $BandNum} {
      set iii $ii
      set comm "Flux"   
    } else {
      set iii [expr $ii-$BandNum]
      set comm "Corr. flux"
    }
      set cmd "puts \$fileid \"[lindex $FluxName $ii]=\$[lindex $FluxName $ii] $units $comm"
      set cmd "$cmd ([lindex $EbandLo $iii]-[lindex $EbandHi $iii]) keV band\""
      eval $cmd
      set cmd "puts \$fileid \"[lindex $FluxName $ii]U=\$[lindex $FluxName $ii]U $units $comm"
      set cmd "$cmd ([lindex $EbandLo $iii]-[lindex $EbandHi $iii]) ${Conf_Level_Flux}% 2-sided limit\""
      eval $cmd
      set cmd "puts \$fileid \"[lindex $FluxName $ii]L=\$[lindex $FluxName $ii]L $units $comm"
      set cmd "$cmd ([lindex $EbandLo $iii]-[lindex $EbandHi $iii]) ${Conf_Level_Flux}% 2-sided limit\""
      eval $cmd  
    } 
close $fileid

# write model to a FITS file
file delete $model_fitsfl   
exec ftemplate template=$temp_headfl outfile=$model_fitsfl
file delete $temp_headfl

# Create a contour plot depicting joint uncertainties between two parameters.
# Someday ....


exit

